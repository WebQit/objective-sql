
import pg from 'pg';
import mysql from 'mysql2';
import Parser from '../src/Parser.js';
import CreateTable from '../src/statement/schema/CreateTable.js';
import AlterTable from '../src/statement/schema/AlterTable.js';
import SQLClient from '../src/database/sql/SQLClient.js';

// PG Client
const pgClient = new pg.Client({
    host: 'localhost',
    port: 5432,
    //user: 'oxharris',
    //password: '',
    //database: 'oxharris',
});
await pgClient.connect();

/*
// MySQL Client
const mysqlClient = await mysql.createConnection({
	host: 'localhost',
    port: 3306,
	//user: 'root',
    //password: '',
    database: 'public',
});
*/

const client = {
    query(sql, ...args) {
        console.log('------------------SQL:', sql);
        return pgClient.query(sql, ...args);
    }
};
const dialect = 'postgres';

//if (dialect === 'mysql') { await client.query(`CREATE DATABASE IF NOT EXISTS public`); }
//console.log(await client.query(`SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS`));
console.log(await client.query(`DROP SCHEMA IF EXISTS obj_information_schema CASCADE`));

const createTableSql = `
CREATE TABLE IF NOT EXISTS test0 (
    id int PRIMARY    KEY CONSTRAINT genn generated by default as identity,
    ref int CONSTRAINT nn not    null CONSTRAINT uni_q unique CONSTRAINT fk REFERENCES pretest (id) MATCH FULL ON DELETE RESTRICT ON UPDATE SET NULL,
    ref2 int,
    rand VARCHAR (11) CHECK (rand IS NOT NULL),
    rand2 text,
    CONSTRAINT ck CHECK (ref > 10),
    CONSTRAINT fk2 FOREIGN    KEY (ref2) REFERENCES pretest2 (id),
    UNIQUE (rand2,rand)
)`;

const alterTableSql = `
ALTER TABLE IF EXISTS public.test
    RENAME AS new_tbl_name,
    RENAME constraint constraint_name1 TO new_constraint_name,

    ADD constraint constraint_name2 PRIMARY KEY (col_name1),
    ADD constraint fruit_type UNIQUE (hhh),
    ADD PRIMARY KEY (col_name2),
    ADD CHECK (check_expr),

    ADD FULLTEXT INDEX (ft_name),

    ADD column new_col varchar(10) FIRST,
    ADD column new_col2 int AFTER refColumn,

    DROP constraint if    exists constraint_name3 cascade,
    DROP PRIMARY KEY,
    DROP FOREIGN KEY fk_name,
    DROP COLUMN if exists col_name,
    DROP col_name,

    ALTER column column_name set data type varchar(60),
    ALTER constraint constraint_name4 INVISIBLE,
    ALTER COLUMN column_name8 SET COMPRESSION compression_method,
    ALTER constraint constraint_name8 DEFERRABLE
`;
//    ALTER column column_name2 set AUTO_INCREMENT,

/*
console.log('');
console.log('');
console.log('Create TABLE pretest');
console.log('');

const sql0 = `
CREATE TABLE IF NOT EXISTS pretest (
    id int primary key,
    desc0 text not null
)`;

const result0 = await client.query(sql0);
console.log(result0);

// --------------------------------------------

console.log('');
console.log('');
console.log('Create TABLE pretest2');
console.log('');

const sql1 = `
CREATE TABLE IF NOT EXISTS pretest2 (
    id int primary key,
    desc0 text not null
)`;

const result1 = await client.query(sql1);
console.log(result1);

// --------------------------------------------

console.log('');
console.log('');
console.log('Create TABLE test0');
console.log('');

const result2 = await client.query(createTableSql);
console.log(result2);

// --------------------------------------------

console.log('');
console.log('');
console.log('Parse CREATE TABLE');
console.log('');

const result5 = await Parser.parse(createTableSql);
console.log(JSON.stringify(result5.toJson(), null, 3));

console.log(result5 + '');
console.log(CreateTable.fromJson(result5.toJson()) + '');

*/
// --------------------------------------------

console.log('');
console.log('');
console.log('Show CREATE TABLE');
console.log('');

const sqlClient = new SQLClient(client, { dialect });

const dbName = 'public2', dbName2 = 'public';
const savepoint = await sqlClient.alterDatabase(dbName, dbSchema => {
    dbSchema.name = dbName2;
}, { savepointDesc: 'To public2' });
console.log('ALTER DATABASE public', savepoint);
const publicDb = sqlClient.database(dbName2);
console.log('public@', await publicDb.savepoint());

const schema1 = {
    name: 'books',
    columns: [
        { name: 'id', type: 'int', primaryKey: true },
        { name: 'author1', type: 'int', references: { table: 'test0', columns: ['id'] }, },
        { name: 'author2', type: 'int', },
        { name: 'content', type: { name: 'varchar', maxLen: 30 }, default: '\'Hello world\'', },
        { name: 'isbn', type: 'int', identity: { always: false }, notNull: true },
    ],
    constraints: [
        { type: 'FOREIGN KEY', columns: ['author2'], references: { table: 'test0', columns: ['id'] } },
        { type: 'UNIQUE KEY', columns: ['author2', 'author1'] },
    ],
    indexes: []
};

await publicDb.dropTable(schema1.name, { ifExists: true });

console.log('CREATE TABLE books IF NOT EXISTS, then DESCRIBE');
await publicDb.createTable(schema1, { ifNotExists: true });
const booksSchema = await sqlClient.database(dbName2).describeTable('books');
console.log(CreateTable.fromJson(booksSchema) + '');

const tt = await sqlClient.database(dbName2).alterTable('books', tblSchema => {
    const isbn = tblSchema.columns.find(col => col.name === 'isbn');
    delete isbn.identity;
});


console.log('----------------------------------------------------------------');


await client.query(`DROP SCHEMA IF EXISTS some_db CASCADE`);
await client.query(`DROP SCHEMA IF EXISTS new_db_name CASCADE`);
try {
    await sqlClient.dropDatabase('some_db', { ifExists: true });
} catch(e) {}

const dbApi = await sqlClient.createDatabase({ name: 'some_db', tables: [
        {
            name: 'test0',
            columns: [
                { name: 'id', type: 'int', primaryKey: true },
            ]
        },
        schema1,
    ]
});
await dbApi.createTable({
    name: 'test1',
    columns: [
        { name: 'id', type: 'int', primaryKey: true },
    ]
});
const sp = await sqlClient.alterDatabase({
    name: 'some_db',
    tables: ['test0', 'test1', 'books'],
}, dbSchema => {
    dbSchema.name = 'new_db_name';
    dbSchema.tables.find(t => t.name === 'test0').columns.find(c => c.name === 'id').notNull = 'test2';
    const i = dbSchema.tables.findIndex(t => t.name === 'test1');
    dbSchema.tables.splice(i, 1);
    dbSchema.tables.push({
        name: 'test2',
        columns: [
            { name: 'id', type: 'int', primaryKey: true },
        ]
    });
});

/*
console.log('ALTER TABLE books', tt);
console.log(await sqlClient.database(dbName2).table('books').savepoint());

// --------------------------------------------

console.log('');
console.log('');
console.log('Parse ALTER TABLE');
console.log('');

const result6 = await Parser.parse(alterTableSql);
console.log(JSON.stringify(result6.toJson(), null, 3));

console.log(result6 + '');
console.log(AlterTable.fromJson(result6.toJson(), result6.params) + '');

// --------------------------------------------


console.log('');
console.log('');
console.log('DIFF >>> ALTER TABLE');
console.log('');

const schemaA = {
    name: 'testt',
    database: 'public',
    columns: [
        { name: 'id', type: { name: 'VARCHAR', maxLen: 30 }, default: 20 },
        { name: 'author', type: { name: 'INT' }, references: { constraintName: 'fkk', table: 'table1', columns: ['col3', 'col4']} },
    ],
    constraints: [
        { type: 'FOREIGN KEY', columns: ['col1', 'col2'], references: { table: 'table1', columns: ['col3', 'col4']} },
        { type: 'PRIMARY KEY', columns: 'col5' },
    ],
    indexes: []
};

const schemaB = {
    name: 'testt',
    database: 'public2',
    columns: [
        { name: 'id3', $name: 'id', notNull: true, type: { name: 'vARCHAR', maxLen: 70 }, default: 20 },
        { name: 'author', type: { name: 'INT' }, references: { constraintName: 'fkk222', $constraintName: 'fkk', table: 'table1', columns: ['col3', 'col5']} },
    ],
    constraints: [
        { type: 'FOREIGN KEY', columns: ['col1', 'col2'], references: { table: 'table1', columns: ['col3', 'col4']} },
        { type: 'PRIMARY KEY', columns: 'col5' },
    ],
    indexes: []
};

const result7 = AlterTable.fromDiffing(schemaA, schemaB);
console.log(JSON.stringify(result7.toJson(), null, 3));

console.log(result7 + '');
console.log(AlterTable.fromJson(result7.toJson(), result7.params) + '');
*/

process.exit();